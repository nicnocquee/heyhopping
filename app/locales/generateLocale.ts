// npx tsx app/locales/generateLocale.ts

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { capitalize } from '../(localized-pages)/[lang]/[country]/[city]/helpers'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const langs = ['en', 'de', 'fr', 'it']
const baseLang = langs[0]
const baseMessagesString = fs.readFileSync(path.join(__dirname, baseLang, 'messages.json'), 'utf-8')
const baseMessagesJson = JSON.parse(baseMessagesString)

const outputDir = path.join(__dirname, 'generated')
const outputFile = path.join(outputDir, 'locales.ts')

fs.mkdirSync(outputDir, { recursive: true })

function arrayToCamelCase(arr: string[]): string {
  const expand = arr.flatMap((item) => {
    const makeItSafe = item.replace(/[^a-zA-Z0-9]+/g, ' ')
    const split = makeItSafe.split(' ')
    const capitalized = split.map((word) => capitalize(word.toLowerCase()))
    return capitalized
  })
  const camelCase = expand.join('')
  return camelCase.charAt(0).toLowerCase() + camelCase.slice(1)
}

const localeFunctions: string[] = ['// This file is auto-generated by generateLocale.ts\n']

const baseKeys = Object.keys(baseMessagesJson)

const errors: string[] = []
const langFunctions: Record<string, Record<string, string>> = {}
langs.forEach((lang) => {
  const messagesString = fs.readFileSync(path.join(__dirname, lang, 'messages.json'), 'utf-8')
  const messagesJson = JSON.parse(messagesString)

  baseKeys.forEach((key) => {
    const functionName = arrayToCamelCase([lang, ...key.split(' ')])
    const value = messagesJson[key]
    if (!value) {
      errors.push(`Missing value for "${key}" in ${lang}`)
    }
    localeFunctions.push(`export const ${functionName} = ${JSON.stringify(value)}`)

    const genericFunctionName = arrayToCamelCase(key.split(' '))
    if (!langFunctions[genericFunctionName]) {
      langFunctions[genericFunctionName] = {}
    }
    langFunctions[arrayToCamelCase(key.split(' '))][lang] = functionName
  })
})

if (errors.length > 0) {
  console.error(errors.join('\n'))
  process.exit(1)
}

Object.keys(langFunctions).forEach((key) => {
  const functionBody = `export const ${key} = (lang: string) => {
  switch (lang) {
${langs
  .map((lang) => {
    return `    case '${lang}':
      return ${langFunctions[key][lang]};`
  })
  .join('\n')}
    default:
        return ${langFunctions[key].en}
    }
}`

  localeFunctions.push(functionBody)
})

fs.writeFileSync(outputFile, localeFunctions.join('\n'))
