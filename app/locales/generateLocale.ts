// npx tsx app/locales/generateLocale.ts

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { capitalize } from '../(localized-pages)/[lang]/[country]/[city]/helpers'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const langs = ['en', 'de', 'fr', 'it']
const baseLang = langs[0]
const baseMessagesString = fs.readFileSync(path.join(__dirname, baseLang, 'messages.json'), 'utf-8')
const baseMessagesJson = JSON.parse(baseMessagesString)

const outputDir = path.join(process.cwd(), 'app/.locales/generated')
const outputFile = path.join(outputDir, 'locales.ts')

fs.mkdirSync(outputDir, { recursive: true })

function arrayToCamelCase(arr: string[]): string {
  const expand = arr.flatMap((item) => {
    const makeItSafe = item.replace(/[^a-zA-Z0-9]+/g, ' ')
    const split = makeItSafe.split(' ')
    const capitalized = split.map((word) => capitalize(word.toLowerCase()))
    return capitalized
  })
  const camelCase = expand.join('')
  return camelCase.charAt(0).toLowerCase() + camelCase.slice(1)
}

const localeFunctions: string[] = [
  '// This file is auto-generated by generateLocale.ts\n',
  `export type SupportedLanguage = ${langs.map((lang) => `'${lang}'`).join(' | ')};`,
]

const baseKeys = Object.keys(baseMessagesJson)

const errors: string[] = []
const langFunctions: Record<string, Record<string, string>> = {}
langs.forEach((lang) => {
  const messagesString = fs.readFileSync(path.join(__dirname, lang, 'messages.json'), 'utf-8')
  const messagesJson = JSON.parse(messagesString)

  baseKeys.forEach((key) => {
    const functionName = arrayToCamelCase([lang, ...key.split(' ')])
    const value = messagesJson[key]
    if (!value) {
      errors.push(`Missing value for "${key}" in ${lang}`)
    }
    localeFunctions.push(`export const ${functionName} = ${JSON.stringify(value)}`)

    const genericFunctionName = arrayToCamelCase(key.split(' '))
    if (!langFunctions[genericFunctionName]) {
      langFunctions[genericFunctionName] = {}
    }
    langFunctions[arrayToCamelCase(key.split(' '))][lang] = functionName
  })
})

if (errors.length > 0) {
  console.error(errors.join('\n'))
  process.exit(1)
}

Object.keys(langFunctions).forEach((key) => {
  const functionBody = `export const ${key} = (lang: SupportedLanguage) => {
  switch (lang) {
${langs
  .map((lang) => {
    return `    case '${lang}':
      return ${langFunctions[key][lang]};`
  })
  .join('\n')}
    default:
        return ${langFunctions[key].en}
    }
}`

  localeFunctions.push(functionBody)
})

fs.writeFileSync(outputFile, localeFunctions.join('\n'))

const markdownOutputFile = path.join(outputDir, 'locales-markdown.tsx')

function componentNameFromFilepath(filepath: string) {
  const parts = filepath
    .split('/')
    .filter((p) => p.trim() !== '.')
    .map((p) => p.replace('.mdx', ''))
  const cameledCase = arrayToCamelCase(parts)
  return cameledCase.charAt(0).toUpperCase() + cameledCase.slice(1)
}

const generateComponent = (markdownContent: string, filepath: string) => {
  // Regular expression to find {props.something}
  const propMatches = markdownContent.match(/\{props\.(\w+)\}/g)
  // @ts-ignore
  const uniqueProps = [...new Set(propMatches?.map((m) => m.match(/props\.(\w+)/)[1]))]

  const componentName = componentNameFromFilepath(filepath)
  const imports = `import ${componentName}Markdown from '${filepath.replace('./', '@/app/locales/')}';\n`
  let typeDefs = ''
  const component = `const ${componentName} = (props: ComponentProps<typeof ${componentName}Markdown>${uniqueProps && uniqueProps.length > 0 ? ' & ' + componentName + 'Props' : ''}) => <${componentName}Markdown {...props} />;`

  if (uniqueProps && uniqueProps.length > 0) {
    typeDefs = `type ${componentName}Props = {\n  ${uniqueProps.map((prop) => `${prop}: string;`).join('\n  ')}\n}\n`
  }

  return {
    componentName,
    componentString: `${imports}${typeDefs}${component}`,
  }
}

function findMdxFiles(dir: string): string[] {
  const entries = fs.readdirSync(dir, { withFileTypes: true })
  const files = entries.map((entry) => {
    const entryPath = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      return findMdxFiles(entryPath)
    } else if (entry.isFile() && entry.name.endsWith('.mdx')) {
      return [entryPath]
    }
    return []
  })
  return files.flat()
}

const mdxFiles = findMdxFiles(path.join(__dirname, '.')).map((p) => p.replace(__dirname, '.'))
const localesMarkdownContent: string[] = [`import { ComponentProps } from 'react';`]

const langComponents: Record<string, Record<string, string>> = {}
mdxFiles.forEach((filepath) => {
  const content = fs.readFileSync(path.join(__dirname, filepath), 'utf-8')
  const [lang, ...rest] = filepath.split('/').filter((p) => p.trim() !== '.')
  const { componentName, componentString } = generateComponent(content, filepath)

  const baseComponentName = componentNameFromFilepath(rest.join('/'))
  if (!langComponents[baseComponentName]) {
    langComponents[baseComponentName] = {}
  }
  langComponents[baseComponentName][lang] = componentName
  localesMarkdownContent.push(componentString)
})

const importStatements: string[] = [`import {  SupportedLanguage } from './locales';`]
const nonImportStatements: string[] = []

localesMarkdownContent
  .join('\n')
  .split('\n')
  .forEach((content) => {
    if (content.startsWith('import')) {
      importStatements.push(content)
    } else {
      nonImportStatements.push(content)
    }
  })

const baseComponents: string[] = []
Object.keys(langComponents).forEach((componentName) => {
  const component = langComponents[componentName]
  const defaultComponent = langComponents[componentName][baseLang]

  const text = `
  
  export const ${componentName} = (props: {lang: SupportedLanguage } & ComponentProps<typeof ${defaultComponent}>) => {
    const { lang, ...rest } = props
    switch (lang) {
      ${langs
        .map((lang) => {
          return `case '${lang}':
          return <${component[lang]} {...rest} />;
        `
        })
        .join('\n')}
      default:
        return <${defaultComponent} {...rest} />
    }
  }
    
`
  baseComponents.push(text)
})

const markdownComponentContent = [
  ...importStatements,
  ...nonImportStatements,
  ...baseComponents,
].join('\n')

fs.writeFileSync(markdownOutputFile, markdownComponentContent)
