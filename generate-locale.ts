// npx tsx generate-locale.ts

import fs from 'fs'
import path from 'path'

const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1)

const localesDir = path.join(process.cwd(), 'locales')
const langs = ['en', 'de', 'fr', 'it']
const baseLang = langs[0]
const baseMessagesString = fs.readFileSync(
  path.join(localesDir, baseLang, 'messages.json'),
  'utf-8'
)
const baseMessagesJson = JSON.parse(baseMessagesString)

const outputDir = path.join(localesDir, '.generated')
const outputFile = path.join(outputDir, 'locales.ts')
const markdownOutputFile = path.join(outputDir, 'locales-markdown.tsx')
const messagesFilename = 'messages.json'

fs.mkdirSync(outputDir, { recursive: true })

function arrayToCamelCase(arr: string[]): string {
  const expand = arr.flatMap((item) => {
    const makeItSafe = item.replace(/[^a-zA-Z0-9]+/g, ' ')
    const split = makeItSafe.split(' ')
    const capitalized = split.map((word) => capitalize(word.toLowerCase()))
    return capitalized
  })
  const camelCase = expand.join('')
  return camelCase.charAt(0).toLowerCase() + camelCase.slice(1)
}

function generatePropTypes(template: string, functionName: string) {
  const regex = /{{\s*(\w+)\s*}}/g // Updated regex to handle spaces
  let match
  const props: Set<string> = new Set()

  while ((match = regex.exec(template)) !== null) {
    props.add(match[1]) // Adding trimmed property name
  }

  if (props.size === 0) {
    return null
  }

  const typeProps = Array.from(props)
    .map((prop) => `  ${prop}: string;`)
    .join('\n')

  return {
    name: `${functionName}Props`,
    content: `type ${functionName}Props = {\n${typeProps}\n}`,
  }
}

const localeFunctions: string[] = [
  '// This file is auto-generated by generate-locale.ts\n',
  `export const replaceData = (text: string, data: Record<string, string>): string => {
    let theText = text
  
    theText = theText.replace(/{{\\s*(\\w+)\\s*}}/g, (match, key) => {
      return key in data ? data[key] : match
    })
  
    return theText
  }`,
  `export type SupportedLanguage = ${langs.map((lang) => `'${lang}'`).join(' | ')};`,
]

const baseKeys = Object.keys(baseMessagesJson)

const errors: string[] = []
const langFunctions: Record<string, Record<string, string>> = {}
const propTypes: Record<string, ReturnType<typeof generatePropTypes>> = {}
langs.forEach((lang) => {
  const messagesString = fs.readFileSync(path.join(localesDir, lang, messagesFilename), 'utf-8')
  const messagesJson = JSON.parse(messagesString)

  baseKeys.forEach((key) => {
    const functionName = arrayToCamelCase([lang, ...key.split(' ')])
    const value = messagesJson[key]
    if (!value) {
      errors.push(`Missing value for "${key}" in ${lang}`)
    }
    localeFunctions.push(`export const ${functionName} = ${JSON.stringify(value)}`)

    const genericFunctionName = arrayToCamelCase(key.split(' '))

    const propType = generatePropTypes(value, genericFunctionName)

    if (propType) {
      if (!propTypes[genericFunctionName]) {
        propTypes[genericFunctionName] = propType
      }
    }

    if (!langFunctions[genericFunctionName]) {
      langFunctions[genericFunctionName] = {}
    }
    langFunctions[arrayToCamelCase(key.split(' '))][lang] = functionName
  })
})

if (errors.length > 0) {
  console.error(errors.join('\n'))
  process.exit(1)
}

Object.keys(langFunctions).forEach((key) => {
  const propType = propTypes[key]
  if (propType) {
    const functionBody = `
    ${propType.content}
    export const ${key} = (lang: SupportedLanguage, data: ${propType.name}) => {
      let text = ''
      switch (lang) {
    ${langs
      .map((lang) => {
        return `case '${lang}':
          text = ${langFunctions[key][lang]};
          break;`
      })
      .join('\n')}
        default:
            text = ${langFunctions[key].en}
        }

      return replaceData(text, data)
    }`

    localeFunctions.push(functionBody)
  } else {
    const functionBody = `export const ${key} = (lang: SupportedLanguage) => {
      switch (lang) {
    ${langs
      .map((lang) => {
        return `    case '${lang}':
          return ${langFunctions[key][lang]};`
      })
      .join('\n')}
        default:
            return ${langFunctions[key].en}
        }
    }`

    localeFunctions.push(functionBody)
  }
})

fs.writeFileSync(outputFile, localeFunctions.join('\n'))

function componentNameFromFilepath(filepath: string) {
  const parts = filepath
    .split('/')
    .filter((p) => p.trim() !== '.')
    .map((p) => p.replace('.mdx', ''))
  const cameledCase = arrayToCamelCase(parts)
  return cameledCase.charAt(0).toUpperCase() + cameledCase.slice(1)
}

const generateComponent = (markdownContent: string, filepath: string) => {
  // Regular expression to find {props.something}
  const propMatches = markdownContent.match(/\{props\.(\w+)\}/g)
  // @ts-ignore
  const uniqueProps = [...new Set(propMatches?.map((m) => m.match(/props\.(\w+)/)[1]))]

  const componentName = componentNameFromFilepath(filepath.replace(localesDir, ''))
  const imports = `import ${componentName}Markdown from '${filepath.replace(localesDir, '..')}';\n`
  let typeDefs = ''
  const component = `const ${componentName} = (props: ComponentProps<typeof ${componentName}Markdown>${uniqueProps && uniqueProps.length > 0 ? ' & ' + componentName + 'Props' : ''}) => <${componentName}Markdown {...props} />;`

  if (uniqueProps && uniqueProps.length > 0) {
    typeDefs = `type ${componentName}Props = {\n  ${uniqueProps.map((prop) => `${prop}: string;`).join('\n  ')}\n}\n`
  }

  return {
    componentName,
    componentString: `${imports}${typeDefs}${component}`,
  }
}

function findMdxFiles(dir: string): string[] {
  const entries = fs.readdirSync(dir, { withFileTypes: true })
  const files = entries.map((entry) => {
    const entryPath = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      return findMdxFiles(entryPath)
    } else if (entry.isFile() && entry.name.endsWith('.mdx')) {
      return [entryPath]
    }
    return []
  })
  return files.flat()
}

const mdxFiles = findMdxFiles(path.join(localesDir, '.'))
const localesMarkdownContent: string[] = [`import { ComponentProps } from 'react';`]

const langComponents: Record<string, Record<string, string>> = {}
mdxFiles.forEach((filepath) => {
  const content = fs.readFileSync(filepath, 'utf-8')
  const [lang, ...rest] = filepath
    .replace(localesDir, '')
    .split('/')
    .filter((p) => p.trim() !== '')
  const { componentName, componentString } = generateComponent(content, filepath)

  const baseComponentName = componentNameFromFilepath(rest.join('/'))

  if (!langComponents[baseComponentName]) {
    langComponents[baseComponentName] = {}
  }
  langComponents[baseComponentName][lang] = componentName
  localesMarkdownContent.push(componentString)
})

const importStatements: string[] = [`import {  SupportedLanguage } from './locales';`]
const nonImportStatements: string[] = []

localesMarkdownContent
  .join('\n')
  .split('\n')
  .forEach((content) => {
    if (content.startsWith('import')) {
      importStatements.push(content)
    } else {
      nonImportStatements.push(content)
    }
  })

const baseComponents: string[] = []
Object.keys(langComponents).forEach((componentName) => {
  const component = langComponents[componentName]
  const defaultComponent = langComponents[componentName][baseLang]

  const text = `export const ${componentName} = (props: {lang: SupportedLanguage } & ComponentProps<typeof ${defaultComponent}>) => {
  const { lang, ...rest } = props
  switch (lang) {${langs
    .map((lang) => {
      return `
    case '${lang}':
      return <${component[lang]} {...rest} />;`
    })
    .join('')}
    default:
      return <${defaultComponent} {...rest} />
  }
}
`
  baseComponents.push(text)
})

const markdownComponentContent = [
  '// This file is auto-generated by generate-locale.ts\n',
  ...importStatements,
  ...nonImportStatements,
  ...baseComponents,
].join('\n')

fs.writeFileSync(markdownOutputFile, markdownComponentContent)
